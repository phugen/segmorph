# Implements functions for validation
# of labels generated by unsupervised algorithms.

import numpy as np
import itertools


class permuter:
    ''' Generates all possible label arrays that can
    be constructed by swapping label pairs and outputs
    one of these each time permute() is called. '''

    def __init__(self, numclasses):
        self.numclasses = numclasses
        #self.already = [set([]) for x in range(numclasses)] # keep track of which permutations were already done
        #self.already[0] = set([0]) # don't do identity permutation
        self.swaps = [] # all swap rules

        # get all possible combinations to swap
        # labels by generating n! permutations of a list
        # in which the position indicates the original
        # label and the value indicates which position
        # the label is switched with.
        perms = itertools.permutations(list(range(self.numclasses)))

        # Prune illegal rules (and don't do identity permutation)
        for rule in perms:
            if self.__is_valid(self.swaps, rule) and rule != tuple(range(self.numclasses)):
                self.swaps.append(rule)

        print self.swaps


    def __is_valid(self, swaps, rule):
        ''' Checks if a swap rule is valid. A swap rule is valid if it is
        symmetric and doesn't already exist in the current swaps list. '''

        # check if rule already added
        if rule in swaps:
            return False

        # check symmetry
        for idx in range(len(rule)):
            s = rule[idx]
            if not rule[s] != idx:
                return False

        # rule is valid.
        return True


    def permute(self, label):
        ''' Generator function that returns one
        image at a time. '''

        # apply one swap rule at a time
        # and return result
        for rule in self.swaps:
            perm = np.array((label))
            print "Permuting according to " + str(rule)

            for idx, sw in enumerate(rule):
                perm[label == idx] = sw

            yield perm



def fmeasure(labels, gt, numclasses):
    ''' Calculates a multi-class F-Measure comparing all permutations
    of the labels calculated by an unsupervised algorithm and returs
    the best (maximum) score and the corresponding labels as a result. '''

    maxscore = 0
    bestlabels = None
    numlabels = labels.size
    permu = permuter(numclasses) # initialize permutation class
    permgen = permu.permute(labels) # initialize permutation generator #NOTE: can be done better.. creating permutations in permute func


    # test all possible permutations
    while labels is not None:

        # calculate multi-class F-Measure by alternatingly
        # treating each class as "true" and all others as "false"
        # and then taking the average score over all classes
        fscore = None
        temp_fscore = 0
        eps = 1e-10 # prevent division by zero
        for c in range(numclasses):

            # true positives (TP):
            # ground truth is class "i" and
            # labels indiciate this class as well
            tp = [gt[i][0] == c and labels[i] == c for i in range(numlabels)] \
                 .count(True) + eps

            # false negatives (FN):
            # ground truth is class "i" but
            # label indicates another class
            fn = [gt[i][0] == c and labels[i] != c for i in range(numlabels)] \
                 .count(True) + eps

            # false positives (FP):
            # ground truth is not class "i" but
            # labels indicates "i" nonetheless
            fp = [gt[i][0] != c and labels[i] == c for i in range(numlabels)] \
                 .count(True) + eps

            # precision
            prec = tp / float(tp + fp)

            # recall
            rec = tp / float(tp + fn)

            # calculate F-measure for current class
            temp_fscore += 2 * ((prec * rec) / (prec + rec))

        # get avergage F-Measure over all classes
        fscore = temp_fscore / float(numclasses)

        # update current best score if needed
        if fscore >= maxscore:
            maxscore = max(maxscore, fscore)
            bestlabels = list(labels) # copy list contents

        # permute the labels until all
        # valid permutations are done
        try:
            labels = permgen.next()
        except StopIteration:
            labels = None


    # after all permutations,
    # return maximum score and the
    # labels associated with that score
    print "Maxscore: " + str(maxscore)
    return maxscore, bestlabels



def labels_as_RGB_image(labels, numclasses):
    ''' Converts a label list back to an RGB image.'''

    labels = np.array(labels).reshape((244, 244))
    outimg = np.zeros((3, 244, 244), dtype=np.uint8)

    # translate labels to colors
    # (NOTE: PIL.save expects RGB)
    redmask = np.array((labels == 1))
    greenmask = np.array((labels == 2))

    outimg[0][redmask == True] = 255
    outimg[1][greenmask == True] = 255

    if numclasses == 4:
        bluemask = np.array((labels == 3))
        outimg[2][bluemask == True] = 255

    # return resulting RGB image
    # in H x W x C format for scikit.misc.imsave
    outimg = np.transpose(outimg, (1, 2, 0))


    return outimg
